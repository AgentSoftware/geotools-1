{"name":"Geotools","tagline":"Geo-related tools PHP 5.3+ library built atop Geocoder and React libraries","body":"Geotools\r\n========\r\n\r\n**Geotools** is a PHP geo-related library, built atop [Geocoder](https://github.com/willdurand/Geocoder) and\r\n[React](https://github.com/reactphp/react) libraries.\r\n\r\n[![Build Status](https://secure.travis-ci.org/toin0u/Geotools.png)](http://travis-ci.org/toin0u/Geotools)\r\n[![project status](http://stillmaintained.com/toin0u/Geotools.png)](http://stillmaintained.com/toin0u/Geotools)\r\n\r\n\r\nFeatures\r\n--------\r\n\r\n* **Batch** geocode & reverse geocoding request(s) in **serie** / in **parallel** against one or a\r\n**set of providers**. [»](#batch)\r\n* Compute geocode & reverse geocoding in the **command-line interface** (CLI) + dumpers and formatters. [»](#cli)\r\n* Accept **almost** all kind of WGS84\r\n[geographic coordinates](http://en.wikipedia.org/wiki/Geographic_coordinate_conversion) as coordinates. [»](#coordinate)\r\n* Support **23 different ellipsoids** and it's easy to provide a new one if needed. [»](#coordinate)\r\n* **Convert** and **format** decimal degrees coordinates to decimal minutes or degrees minutes seconds coordinates.\r\n[»](#convert)\r\n* **Convert** decimal degrees coordinates in the\r\n[Universal Transverse Mercator](http://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system)\r\n(UTM) projection. [»](#convert)\r\n* Compute the distance in **meter** (by default), **km**  or **mile** between two coordinates using **flat**,\r\n**haversine** or **vincenty** algorithms. [»](#distance)\r\n* Compute the initial and final **bearing** from the origin coordinate to the destination coordinate in degrees. [»](#point)\r\n* Compute the initial and final **cardinal point** (direction) from the origin coordinate to the destination\r\ncoordinate, read more in [wikipedia](http://en.wikipedia.org/wiki/Cardinal_direction). [»](#point)\r\n* Compute the **half-way point** (coordinate) between the origin and the destination coordinates. [»](#point)\r\n* Compute the **destination point** (coordinate) with given bearing in degrees and a distance in meters. [»](#point)\r\n* Encode a coordinate to a **geo hash** string and decode it to a coordinate, read more in\r\n[wikipedia](http://en.wikipedia.org/wiki/Geohash) and on [geohash.org](http://geohash.org/). [»](#geohash)\r\n* A **command-line interface** (CLI) for **Distance**, **Point**, **Geohash** and **Convert** classes. [»](#cli)\r\n* ... more to come ...\r\n\r\n\r\nInstallation\r\n------------\r\n\r\nGeotools can be found on [Packagist](https://packagist.org/packages/toin0u/geotools).\r\nThe recommended way to install Geotools is through [composer](http://getcomposer.org).\r\n\r\nRun these commands to install composer, Geotools and its dependencies:\r\n\r\n``` bash\r\n% curl -sS https://getcomposer.org/installer | php\r\n```\r\nOr\r\n``` bash\r\n% wget http://getcomposer.org/composer.phar\r\n```\r\nThen\r\n``` bash\r\n% php composer.phar init --require=\"toin0u/geotools:@stable\" -n\r\n% php composer.phar install\r\n```\r\n\r\nNow you can add the autoloader, and you will have access to the library:\r\n\r\n``` php\r\n<?php\r\n\r\nrequire 'vendor/autoload.php';\r\n```\r\n\r\nIf you don't use neither **Composer** nor a _ClassLoader_ in your application, just require the provided autoloader:\r\n\r\n``` php\r\n<?php\r\n\r\nrequire_once 'src/autoload.php';\r\n```\r\n\r\n\r\nUsage & API\r\n-----------\r\n\r\n### Coordinate & Ellipsoid ###\r\n\r\nThe default geodetic datum is [WGS84](http://en.wikipedia.org/wiki/World_Geodetic_System) and coordinates are in\r\ndecimal degrees.\r\n\r\nHere are the available ellipsoid: `AIRY`, `AUSTRALIAN_NATIONAL`, `BESSEL_1841`, `BESSEL_1841_NAMBIA`,\r\n`CLARKE_1866`, `CLARKE_1880`, `EVEREST`, `FISCHER_1960_MERCURY`, `FISCHER_1968`, `GRS_1967`, `GRS_1980`,\r\n`HELMERT_1906`, `HOUGH`, `INTERNATIONAL`, `KRASSOVSKY`, `MODIFIED_AIRY`, `MODIFIED_EVEREST`,\r\n`MODIFIED_FISCHER_1960`, `SOUTH_AMERICAN_1969`, `WGS60`, `WGS66`, `WGS72`, and `WGS84`.\r\n\r\nIf you need to use an other ellipsoid, just create an array like this:\r\n``` php\r\n<?php\r\n\r\n$myEllipsoid = \\Geotools\\Coordinate\\Ellipsoid::createFromArray(array(\r\n    'name' => 'My Ellipsoid', // The name of the Ellipsoid\r\n    'a'    => 123.0, // The semi-major axis (equatorial radius) in meters\r\n    'invF' => 456.0 // The inverse flattening\r\n));\r\n```\r\n\r\n**Geotools** is built atop [Geocoder](https://github.com/willdurand/Geocoder). It means it's possible to use the\r\n`\\Geocoder\\Result\\ResultInterface` directly but it's also possible to use a *string* or a simple *array* with its\r\nlatitude and longitude.\r\n\r\nIt supports [valid and acceptable geographic coordinates](http://en.wikipedia.org/wiki/Geographic_coordinate_conversion)\r\nlike:\r\n* 40:26:46N,079:56:55W\r\n* 40:26:46.302N 079:56:55.903W\r\n* 40°26′47″N 079°58′36″W\r\n* 40d 26′ 47″ N 079d 58′ 36″ W\r\n* 40.446195N 79.948862W\r\n* 40.446195, -79.948862\r\n* 40° 26.7717, -79° 56.93172\r\n\r\nLatitudes below -90.0 or above 90.0 degrees are *capped* through `\\Geotools\\Coordinate\\Coordinate::normalizeLatitude()`.  \r\nLongitudes below -180.0 or abode 180.0 degrees are *wrapped* through `\\Geotools\\Coordinate\\Coordinate::normalizeLongitude()`.\r\n\r\n``` php\r\n<?php\r\n\r\nuse Geotools\\Coordinate\\Coordinate;\r\nuse Geotools\\Coordinate\\Ellipsoid;\r\n\r\n// from an \\Geocoder\\Result\\ResultInterface instance within Airy ellipsoid\r\n$coordinate = new Coordinate($geocoderResult, Ellipsoid::createEllipsoid(Ellipsoid::AIRY));\r\n// or in an array of latitude/longitude coordinate within GRS 1980 ellipsoid\r\n$coordinate = new Coordinate(array(48.8234055, 2.3072664), Ellipsoid::createEllipsoid(Ellipsoid::GRS_1980));\r\n// or in latitude/longitude coordinate within WGS84 ellipsoid\r\n$coordinate = new Coordinate('48.8234055, 2.3072664');\r\n// or in degrees minutes seconds coordinate within WGS84 ellipsoid\r\n$coordinate = new Coordinate('48°49′24″N, 2°18′26″E');\r\n// or in decimal minutes cordinate within WGS84 ellipsoid\r\n$coordinate = new Coordinate('48 49.4N, 2 18.43333E');\r\n// the result will be:\r\nprintf(\"Latitude: %F\\n\", $coordinate->getLatitude()); // 48.8234055\r\nprintf(\"Longitude: %F\\n\", $coordinate->getLongitude()); // 2.3072664\r\nprintf(\"Ellipsoid name: %s\\n\", $coordinate->getEllipsoid()->getName()); // WGS 84\r\nprintf(\"Equatorial radius: %F\\n\", $coordinate->getEllipsoid()->getA()); // 6378136.0\r\nprintf(\"Polar distance: %F\\n\", $coordinate->getEllipsoid()->getB()); // 6356751.317598\r\nprintf(\"Inverse flattening: %F\\n\", $coordinate->getEllipsoid()->getInvF()); // 298.257224\r\nprintf(\"Mean radius: %F\\n\", $coordinate->getEllipsoid()->getArithmeticMeanRadius()); // 6371007.772533\r\n```\r\n\r\n### Convert ###\r\n\r\nIt provides methods (and aliases) to convert *decimal degrees* WGS84 coordinates to *degrees minutes seconds*\r\nor *decimal minutes* WGS84 coordinates. You can format the output string easily.\r\n\r\nYou can also convert them in the Universal Transverse Mercator (UTM) projection (Southwest coast of Norway and the\r\nregion of Svalbard are covered).\r\n\r\n``` php\r\n<?php\r\n\r\n$geotools = new \\Geotools\\Geotools();\r\n$coordinate = new \\Geotools\\Coordinate\\Coordinate('40.446195, -79.948862');\r\n$convert = $geotools->convert($coordinate);\r\n// convert to decimal degrees without and with format string\r\nprintf(\"%s\\n\", $convert->toDecimalMinutes()); // 40 26.7717N, -79 56.93172W\r\nprintf(\"%s\\n\", $convert->toDM('%P%D°%N %p%d°%n')); // 40°26.7717 -79°56.93172\r\n// convert to degrees minutes seconds without and with format string\r\nprintf(\"%s\\n\", $convert->toDegreesMinutesSeconds('<p>%P%D:%M:%S, %p%d:%m:%s</p>')); // <p>40:26:46, -79:56:56</p>\r\nprintf(\"%s\\n\", $convert->toDMS()); // 40°26′46″N, 79°56′56″W\r\n// convert in the UTM projection (standard format)\r\nprintf(\"%s\\n\", $convert->toUniversalTransverseMercator()); // 17T 589138 4477813\r\nprintf(\"%s\\n\", $convert->toUTM()); // 17T 589138 4477813 (alias)\r\n```\r\n\r\nHere is the mapping:\r\n\r\n**Decimal minutes** | Latitude | Longitude\r\n--- | --- | ---\r\nPositive or negative sign | `%P` | `%p`\r\nDirection | `%L` | `%l`\r\nDegrees | `%D` | `%d`\r\nDecimal minutes | `%N` | `%n`\r\n\r\n**Degrees minutes seconds** | Latitude | Longitude\r\n--- | --- | ---\r\nPositive or negative sign | `%P` | `%p`\r\nDirection | `%L` | `%l`\r\nDegrees | `%D` | `%d`\r\nMinutes | `%M` | `%m`\r\nSeconds | `%S` | `%s`\r\n\r\n### Batch ###\r\n\r\nIt provides a very handy way to batch geocode and reverse geocoding requests in *serie* or in *parallel* against\r\na set of providers.  \r\nThanks to [Geocoder](https://github.com/willdurand/Geocoder) and [React](https://github.com/reactphp/react) libraries.\r\n\r\nIt's possible to batch *one request* (a string) or a *set of request* (an array) against *one provider* or\r\n*set of providers*.\r\n\r\n``` php\r\n<?php\r\n\r\n$geocoder = new \\Geocoder\\Geocoder();\r\n$adapter  = new \\Geocoder\\HttpAdapter\\CurlHttpAdapter();\r\n\r\n$geocoder->registerProviders(array(\r\n    new \\Geocoder\\Provider\\GoogleMapsProvider($adapter),\r\n    new \\Geocoder\\Provider\\OpenStreetMapsProvider($adapter),\r\n    new \\Geocoder\\Provider\\BingMapsProvider($adapter, '<FAKE_API_KEY>'), // throws InvalidCredentialsException\r\n    new \\Geocoder\\Provider\\YandexProvider($adapter),\r\n    new \\Geocoder\\Provider\\FreeGeoIpProvider($adapter),\r\n    new \\Geocoder\\Provider\\GeoipProvider(),\r\n));\r\n\r\n$geotools = new \\Geotools\\Geotools();\r\n$results  = $geotools->batch($geocoder)->geocode(array(\r\n    'Paris, France',\r\n    'Copenhagen, Denmark',\r\n    '74.200.247.59',\r\n    '::ffff:66.147.244.214'\r\n))->parallel();\r\n\r\n$dumper = new \\Geocoder\\Dumper\\WktDumper();\r\nforeach ($results as $result) {\r\n    // if a provider throws an exception (UnsupportedException, InvalidCredentialsException ...)\r\n    // an empty /Geocoder/Result/Geocoded instance is returned. It's possible to use dumpers\r\n    // and/or formatters from the Geocoder library\r\n    printf(\"%s\\n\", $dumper->dump($result));\r\n}\r\n```\r\n\r\nYou should get 24 results (4 values to geocode against 6 providers) something like:\r\n\r\n```\r\nPOINT(2.352222 48.856614) // GoogleMapsProvider, OK! Address-based supported\r\nPOINT(12.568337 55.676097) // GoogleMapsProvider, OK! Address-based supported\r\nPOINT(0.000000 0.000000) // GoogleMapsProvider, IPv4 UnsupportedException thrown\r\nPOINT(0.000000 0.000000) // GoogleMapsProvider, IPv6 UnsupportedException thrown\r\nPOINT(2.320035 48.858841) // OpenStreetMapsProvider, OK! Address-based supported\r\nPOINT(12.570069 55.686724) // OpenStreetMapsProvider, OK! Address-based supported\r\nPOINT(0.000000 0.000000) // OpenStreetMapsProvider, IPv4 UnsupportedException thrown\r\nPOINT(0.000000 0.000000) // OpenStreetMapsProvider, IPv6 UnsupportedException thrown\r\nPOINT(0.000000 0.000000) // BingMapsProvider, InvalidCredentialsException thrown\r\nPOINT(0.000000 0.000000) // BingMapsProvider, InvalidCredentialsException thrown\r\nPOINT(0.000000 0.000000) // BingMapsProvider, InvalidCredentialsException thrown\r\nPOINT(0.000000 0.000000) // BingMapsProvider, InvalidCredentialsException thrown\r\nPOINT(2.341198 48.856929) // YandexProvider, OK! Address-based supported\r\nPOINT(12.567602 55.675682) // YandexProvider, OK! Address-based supported\r\nPOINT(0.000000 0.000000) // YandexProvider, IPv4 UnsupportedException thrown\r\nPOINT(0.000000 0.000000) // YandexProvider, IPv6 UnsupportedException thrown\r\nPOINT(0.000000 0.000000) // FreeGeoIpProvider, Address-based UnsupportedException thrown\r\nPOINT(0.000000 0.000000) // FreeGeoIpProvider, Address-based UnsupportedException thrown\r\nPOINT(-122.415600 37.748400) // FreeGeoIpProvider, OK! IPv4 supported\r\nPOINT(-111.613300 40.218100) // FreeGeoIpProvider, OK! IPv6 supported\r\nPOINT(0.000000 0.000000) // GeoipProvider, Address-based UnsupportedException thrown\r\nPOINT(0.000000 0.000000) // GeoipProvider, Address-based UnsupportedException thrown\r\nPOINT(-122.415604 37.748402) // GeoipProvider, OK! IPv4 supported\r\nPOINT(0.000000 0.000000) // GeoipProvider, NoResultException thrown but IPv6 is supported\r\n```\r\n\r\nBatch reverse geocoding is something like:\r\n\r\n``` php\r\n<?php\r\n\r\n// ... $geocoder like the previous example ...\r\n// If you want to reverse one coordinate\r\n$results = $geotools->batch($geocoder)->reverse(\r\n    new \\Geotools\\Coordinate\\Coordinate(array(2.307266, 48.823405))\r\n)->parallel();\r\n// Or if you want to reverse geocoding 3 coordinates\r\n$coordinates = array(\r\n    new \\Geotools\\Coordinate\\Coordinate(array(2.307266, 48.823405)),\r\n    new \\Geotools\\Coordinate\\Coordinate(array(12.568337, 55.676097)),\r\n    new \\Geotools\\Coordinate\\Coordinate('-74.005973 40.714353')),\r\n);\r\n$results = $geotools->batch($geocoder)->reverse($coordinates)->parallel();\r\n// ...\r\n```\r\n\r\nIf you want to batch it in serie, replace the method `parallel()` by `serie()`.\r\n\r\nTo optimize batch requests you need to register providers according to their **capabilities** and what you're\r\n**looking for** (geocode street addresses, geocode IPv4, geocode IPv6 or reverse geocoding),\r\nplease read more at the [Geocoder library doc](https://github.com/willdurand/Geocoder#freegeoipprovider).\r\n\r\n### Distance ###\r\n\r\nIt provides methods to compute the distance in *meter* (by default), *km* or *mile* between two coordinates\r\nusing *flat* (most performant), *haversine* or *vincenty* (most accurate) algorithms.\r\n\r\nThose coordinates should be in the same ellipsoid.\r\n\r\n``` php\r\n<?php\r\n\r\n$geotools = new \\Geotools\\Geotools();\r\n$coordA   = new \\Geotools\\Coordinate\\Coordinate(array(48.8234055, 2.3072664));\r\n$coordB   = new \\Geotools\\Coordinate\\Coordinate(array(43.296482, 5.36978));\r\n\r\necho $geotools->distance()->setFrom($coordA)->setTo($coordB)->flat(); // 661220.36979254 (meters)\r\necho $geotools->distance()->setFrom($coordA)->setTo($coordB)->in('km')->haversine(); // 659.16650524477\r\necho $geotools->distance()->setFrom($coordA)->setTo($coordB)->in('mile')->vincenty(); // 410.41281759044\r\n```\r\n\r\n### Point ###\r\n\r\nIt provides methods to compute the initial and final *bearing* in degrees, the initial and final *cardinal direction*,\r\nthe *middle point* and the *destination point*. The middle and the destination points returns a\r\n`\\Geotools\\Coordinate\\Coordinate` object.\r\n\r\n``` php\r\n<?php\r\n\r\n$geotools = new \\Geotools\\Geotools();\r\n$coordA   = new \\Geotools\\Coordinate\\Coordinate(array(48.8234055, 2.3072664));\r\n$coordB   = new \\Geotools\\Coordinate\\Coordinate(array(43.296482, 5.36978));\r\n\r\necho $geotools->point()->setFrom($coordA)->setTo($coordB)->initialBearing(); // 157 (degrees)\r\necho $geotools->point()->setFrom($coordA)->setTo($coordB)->initialCardinal(); // SSE (SouthSouthEast)\r\necho $geotools->point()->setFrom($coordA)->setTo($coordB)->finalBearing(); // 160 (degrees)\r\necho $geotools->point()->setFrom($coordA)->setTo($coordB)->finalCardinal(); // SSE (SouthSouthEast)\r\n\r\n$middlePoint = $geotools->point()->setFrom($coordA)->setTo($coordB)->middle(); // \\Geotools\\Coordinate\\Coordinate\r\necho $middlePoint->getLatitude(); // 46.070143125815\r\necho $middlePoint->getLongitude(); // 3.9152401085931\r\n\r\n$destinationPoint = $geotools->point()->setFrom($coordA)->destination(180, 200000); // \\Geotools\\Coordinate\\Coordinate\r\necho $destinationPoint->getLatitude(); // 47.026774663314\r\necho $destinationPoint->getLongitude(); // 2.3072664\r\n```\r\n\r\n\r\n### Geohash ###\r\n\r\nIt provides methods to get the *geo hash* and its *bounding box's coordinates* of a coordinate and the\r\n*coordinate* and its *bounding box's coordinates* of a geo hash.\r\n\r\n``` php\r\n<?php\r\n\r\n$geotools       = new \\Geotools\\Geotools();\r\n$coordToGeohash = new \\Geotools\\Coordinate\\Coordinate('43.296482, 5.36978');\r\n\r\n// encoding\r\n$geotools->geohash()->encode($coordToGeohash, 3)->getGeohash(); // spe\r\n$encoded = $geotools->geohash()->encode($coordToGeohash); // 12 is the default length\r\necho $encoded->getGeohash(); // spey61yhkcnp\r\n$boundingBox = $encoded->getBoundingBox(); // returns an array of \\Geotools\\Coordinate\\CordinateInterface\r\n\r\n// decoding\r\n$decoded = $geotools->geohash()->decode('spey61y');\r\necho $decoded->getCoordinate()->getLatitude(); // 43.296432495117\r\necho $decoded->getCoordinate()->getLongitude(); // 5.3702545166016\r\n$boundingBox = $decoded->getBoundingBox(); // returns an array of \\Geotools\\Coordinate\\CordinateInterface\r\n```\r\n\r\n### CLI ###\r\n\r\nIt provides command lines to compute methods provided by **Distance**, **Point**, **Geohash** and **Convert** classes.\r\nThanks to the [Symfony Console Component](https://github.com/symfony/Console).\r\n\r\n``` bash\r\n% php geotools list // list of available commands\r\n% php geotools distance:flat \"40° 26.7717, -79° 56.93172\" \"30°16′57″N 029°48′32″W\" // 4690203.1048522\r\n% php geotools distance:vincenty \"35,45\" \"45,35\" --km  // 1398.4080717661\r\n% php geotools point:initial-cardinal \"40:26:46.302N 079:56:55.903W\" \"43.296482, 5.36978\" // NE (NordEast)\r\n% php geotools point:final-cardinal \"40:26:46.302N 079:56:55.903W\" \"43.296482, 5.36978\" // ESE (EastNorthEast)\r\n% php geotools geohash:encode \"40° 26.7717, -79° 56.93172\" --length=3 // returns dpp\r\n% php geotools convert:dm \"40.446195, -79.948862\" --format=\"%P%D°%N %p%d°%n\" // 40°26.7717 -79°56.93172\r\n% php geotools convert:dms \"40.446195, -79.948862\" --format=\"%P%D:%M:%S, %p%d:%m:%s\" // 40:26:46, -79:56:56\r\n% php geotools convert:utm \"60.3912628, 5.3220544\" // 32V 297351 6700644\r\n...\r\n```\r\n\r\nCompute street addresses, IPv4s or IPv6s geocoding and reverse geocoding right in your console.\r\n\r\nIt's possible to define and precise your request through these options:\r\n* `--adapter`: `socket`, `buzz`, `zend`, `guzzle` or `curl` by default.\r\n* `--provider`: `bing_maps`, `yahoo`, `maxmind`... `google_maps` is the default one. See the full list\r\n[here](https://github.com/willdurand/Geocoder#providers).\r\n* `--raw`: the result output in RAW format, shows Adapter, Provider and Arguments if any.\r\n* `--json`: the result output in JSON string format.\r\n* `--args`: this option accepts multiple values (e.g. --args=\"API_KEY\" --args=\"LOCALE\") if your provider needs or\r\ncan have arguments.\r\n* `--dumper`: this option is available for geocoding, `gpx`, `geojson`, `kml`, `wkb` and `wkt` by default.\r\nRead more [here](https://github.com/willdurand/Geocoder#dumpers).\r\n* `--format`: this option is available for reverse geocoding, see the mapping\r\n[here](https://github.com/willdurand/Geocoder#formatter).\r\n\r\n``` bash\r\n% php geotools geocoder:geocode \"Copenhagen, Denmark\" // 55.6760968, 12.5683371\r\n% php geotools geocoder:geocode \"74.200.247.59\" --provider=\"free_geo_ip\" --adapter=\"socket\" // 37.7484, -122.4156\r\n% php geotools geocoder:geocode Paris --args=\"fr_FR\" --args=\"France\" --args=\"true\" // 48.856614, 2.3522219\r\n% php geotools geocoder:geocode Paris --dumper=wkt // POINT(2.352222 48.856614)\r\n...\r\n% php geotools geocoder:reverse \"48.8631507, 2.388911\" // Avenue Gambetta 10, 75020 Paris\r\n% php geotools geocoder:reverse \"48.8631507, 2.388911\" --format=\"%L, %R, %C\" // Paris, Île-De-France, France\r\n% php geotools geocoder:reverse \"48.8631507, 2.388911\" --format=\"%L, %R, %C\" --provider=\"openstreetmaps\"\r\n// Paris, Île-De-France, France Métropolitaine\r\n...\r\n% php geotools geocoder:geocode \"Tagensvej 47, Copenhagen\" --raw --args=da_DK --args=Denmark --adapter=socket\r\n```\r\n\r\nThe last command will show an output like this:\r\n\r\n```\r\nAdapter:       \\Geocoder\\HttpAdapter\\SocketHttpAdapter\r\nProvider:      \\Geocoder\\Provider\\GoogleMapsProvider\r\nArguments:     da_DK,Denmark\r\n---\r\nLatitude:      55.699953\r\nLongitude:     12.552736\r\nBounds\r\n L South: 55.699953\r\n L West:  12.552736\r\n L North: 55.699953\r\n L East:  12.552736\r\nStreet Number: 47\r\nStreet Name:   Tagensvej\r\nZipcode:       2200\r\nCity:          Copenhagen\r\nCity District: København N\r\nCounty:        København\r\nCounty Code:   KØBENHAVN\r\nRegion:        Capital Region Of Denmark\r\nRegion Code:   CAPITAL REGION OF DENMARK\r\nCountry:       Denmark\r\nCountry Code:  DK\r\nTimezone:\r\n```\r\n\r\nUnit Tests\r\n----------\r\n\r\nTo run unit tests, you'll need the `cURL` extension and a set of dependencies, you can install them using Composer:\r\n\r\n``` bash\r\n% php composer.phar install --dev\r\n```\r\n\r\nOnce installed, just launch the following command:\r\n\r\n``` bash\r\n% phpunit --coverage-text\r\n```\r\n\r\n\r\nContributing\r\n------------\r\n\r\nPlease see [CONTRIBUTING](CONTRIBUTING.md) for details.\r\n\r\n\r\nCredits\r\n-------\r\n\r\n* Antoine Corcy <contact@sbin.dk>\r\n* [All contributors](https://github.com/toin0u/Geotools/contributors)\r\n\r\n\r\nAcknowledgments\r\n---------------\r\n* [Geocoder](http://geocoder-php.org/)\r\n* [ReactPHP](http://reactphp.org/)\r\n* [Symfony Console Component](https://github.com/symfony/Console)\r\n* [Geokit](https://github.com/jsor/Geokit),\r\n[Geotools-for-CodeIgniter](https://github.com/weejames/Geotools-for-CodeIgniter),\r\n[geotools-php](https://github.com/jillesvangurp/geotools-php) ...\r\n\r\n\r\nChangelog\r\n---------\r\n\r\n[See the changelog file](CHANGELOG.md)\r\n\r\n\r\nSupport\r\n-------\r\n\r\n[Please open an issues in github](https://github.com/toin0u/Geotools/issues)\r\n\r\n\r\nLicense\r\n-------\r\n\r\nGeotools is released under the MIT License. See the bundled [LICENSE](LICENSE) file for details.\r\n","google":"UA-38870291-1","note":"Don't delete this file! It's used internally to help with page regeneration."}